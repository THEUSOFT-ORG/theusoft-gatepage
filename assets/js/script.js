/**
 * @fileoverview Script de gerenciamento de preloader e redirecionamento
 * @module PreloaderManager
 * @version 1.2.0
 * @copyright ¬© 2025.2 ·π™HE√úSOFT ‚Äì ·π™ECNOLOGIA Q√úE APR√ñXIMA, ED√úCA√á√ÉO Q√úE TRANSF√ñRMA
 * @license MIT
 */

// CONSTANTES DE CONFIGURA√á√ÉO
const CONFIG = {
    PRELOADER_MIN_DISPLAY_TIME: 2000,
    REDIRECT_DELAY: 800,
    HEALTH_CHECK_TIMEOUT: 5000,
    TYPING_SPEED: 40,
    GREETING_UPDATE_INTERVAL: 60000,
    SERVER_HEALTH_URL: 'https://theusoft.shop/health',
    REDIRECT_URL: 'https://theusoft.shop/',
    MAX_RETRY_ATTEMPTS: 2,
    RETRY_DELAY: 1000
};

// Vari√°veis de estado do aplicativo
let appState = {
    pageLoaded: false,
    minTimeElapsed: false,
    isServerOnline: null,
    healthCheckRetries: 0,
    typingInterval: null,
    greetingInterval: null,
    isRedirecting: false
};

// Seletores de elementos DOM
const DOM_SELECTORS = {
    preloader: '#preloader',
    greeting: '#greeting',
    message: '.message',
    copyright: '#copyright-notice'
};

/**
 * Verifica o status do servidor com tratamento robusto de CORS e erros
 * @async
 * @function checkServerStatus
 * @returns {Promise<boolean>} True se o servidor estiver online, false caso contr√°rio
 */
async function checkServerStatus() {
    // Se j√° excedeu o n√∫mero m√°ximo de tentativas, retorna offline
    if (appState.healthCheckRetries >= CONFIG.MAX_RETRY_ATTEMPTS) {
        console.log('‚ùå N√∫mero m√°ximo de tentativas excedido, considerando servidor offline');
        return false;
    }

    try {
        console.log(`üîç Verificando status do servidor: ${CONFIG.SERVER_HEALTH_URL}`);
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), CONFIG.HEALTH_CHECK_TIMEOUT);
        
        const response = await fetch(CONFIG.SERVER_HEALTH_URL, {
            method: 'GET',
            cache: 'no-store',
            referrerPolicy: 'no-referrer',
            signal: controller.signal
        });
        
        clearTimeout(timeoutId);
        
        console.log(`üìä Resposta do servidor: Status ${response.status} ${response.statusText}`);
        
        // Considera online se o status for 2xx
        const isOnline = response.ok;
        if (isOnline) {
            console.log('‚úÖ Servidor online, pronto para redirecionar');
        } else {
            console.log(`‚ùå Servidor respondeu com erro: ${response.status}`);
        }
        
        return isOnline;
    } catch (error) {
        // Log espec√≠fico para diferentes tipos de erro
        if (error.name === 'AbortError') {
            console.log('‚è∞ Timeout na verifica√ß√£o do servidor');
            appState.healthCheckRetries++;
            await new Promise(resolve => setTimeout(resolve, CONFIG.RETRY_DELAY));
            return checkServerStatus();
        } else if (error.name === 'TypeError' && error.message.includes('Failed to fetch')) {
            console.log('üåê Erro de rede/CORS na verifica√ß√£o do servidor');
        } else {
            console.log(`‚ö†Ô∏è Erro inesperado: ${error.message}`);
        }
        
        appState.healthCheckRetries++;
        return false;
    }
}

/**
 * Verifica o status do servidor usando uma abordagem alternativa por imagem
 * √ötil para contornar limita√ß√µes de CORS
 * @async
 * @function checkServerStatusWithImage
 * @returns {Promise<boolean>} True se o servidor estiver online
 */
async function checkServerStatusWithImage() {
    console.log('üñºÔ∏è Tentando verifica√ß√£o alternativa por imagem');
    return new Promise((resolve) => {
        const img = new Image();
        let resolved = false;
        
        // Timeout para evitar que fique travado
        const timeoutId = setTimeout(() => {
            if (!resolved) {
                resolved = true;
                console.log('‚è∞ Timeout na verifica√ß√£o por imagem');
                resolve(false);
            }
        }, CONFIG.HEALTH_CHECK_TIMEOUT);
        
        img.onload = () => {
            if (!resolved) {
                resolved = true;
                clearTimeout(timeoutId);
                console.log('‚úÖ Verifica√ß√£o por imagem: servidor online');
                resolve(true);
            }
        };
        
        img.onerror = () => {
            if (!resolved) {
                resolved = true;
                clearTimeout(timeoutId);
                console.log('‚ùå Verifica√ß√£o por imagem: servidor offline');
                resolve(false);
            }
        };
        
        // Tenta carregar uma imagem do dom√≠nio (usando cache busting)
        img.src = `${CONFIG.SERVER_HEALTH_URL.replace('/health', '/favicon.ico')}?t=${Date.now()}`;
    });
}

/**
 * Verifica√ß√£o robusta de status do servidor usando m√∫ltiplos m√©todos
 * @async
 * @function robustServerStatusCheck
 * @returns {Promise<boolean>} True se o servidor estiver online
 */
async function robustServerStatusCheck() {
    console.log('üõ°Ô∏è Iniciando verifica√ß√£o robusta do servidor');
    try {
        // Primeiro tenta o m√©todo tradicional
        const traditionalCheck = await checkServerStatus();
        if (traditionalCheck) {
            console.log('üéØ M√©todo tradicional confirmou servidor online');
            return true;
        }
        
        console.log('üîÑ Tentando m√©todo alternativo...');
        // Se falhou, tenta o m√©todo alternativo por imagem
        const imageCheck = await checkServerStatusWithImage();
        if (imageCheck) {
            console.log('üéØ M√©todo alternativo confirmou servidor online');
        } else {
            console.log('‚ùå Todos os m√©todos indicam servidor offline');
        }
        return imageCheck;
    } catch (error) {
        console.log(`‚ö†Ô∏è Erro inesperado na verifica√ß√£o robusta: ${error.message}`);
        return false;
    }
}

/**
 * Oculta o preloader com transi√ß√£o suave
 * @function hidePreloader
 */
function hidePreloader() {
    console.log('üëã Ocultando preloader (servidor offline)');
    const preloader = document.querySelector(DOM_SELECTORS.preloader);
    if (!preloader) return;
    
    preloader.classList.add('hidden');
    setTimeout(() => {
        preloader.style.display = 'none';
    }, CONFIG.REDIRECT_DELAY);
}

/**
 * Redireciona para a URL especificada
 * @function redirectToHome
 */
function redirectToHome() {
    if (appState.isRedirecting) {
        console.log('‚è≠Ô∏è Redirecionamento j√° em andamento');
        return;
    }
    
    appState.isRedirecting = true;
    console.log(`üîÄ Redirecionando para: ${CONFIG.REDIRECT_URL}`);
    
    // Pequeno delay para garantir que o usu√°rio veja a transi√ß√£o
    setTimeout(() => {
        window.location.href = CONFIG.REDIRECT_URL;
    }, 300);
}

/**
 * Gerencia a l√≥gica de esconder o preloader ou redirecionar
 * @async
 * @function handlePreloaderState
 */
async function handlePreloaderState() {
    if (!appState.pageLoaded || !appState.minTimeElapsed) {
        console.log(`‚è≥ Aguardando condi√ß√µes: pageLoaded=${appState.pageLoaded}, minTimeElapsed=${appState.minTimeElapsed}`);
        return;
    }
    
    console.log('üéØ Condi√ß√µes atendidas, verificando estado do servidor...');
    
    // Verifica status do servidor apenas uma vez
    if (appState.isServerOnline === null) {
        appState.isServerOnline = await robustServerStatusCheck();
    }
    
    if (appState.isServerOnline) {
        redirectToHome();
    } else {
        hidePreloader();
    }
}

/**
 * Atualiza a sauda√ß√£o conforme o hor√°rio do dia
 * @function updateGreeting
 */
function updateGreeting() {
    const hour = new Date().getHours();
    const greetingElement = document.querySelector(DOM_SELECTORS.greeting);
    if (!greetingElement) return;
    
    let greeting;
    
    if (hour >= 5 && hour < 12) {
        greeting = "B√∂m dia!";
    } else if (hour >= 12 && hour < 18) {
        greeting = "B√∂a tarde!";
    } else if (hour >= 18 && hour < 24) {
        greeting = "B√∂a noite!";
    } else {
        greeting = "B√∂a madrugada!";
    }
    
    greetingElement.textContent = greeting;
}

/**
 * Efeito de digita√ß√£o para a mensagem de manuten√ß√£o
 * @function typeWriter
 * @param {string} text - Texto a ser exibido com efeito de digita√ß√£o
 * @param {number} index - √çndice atual do caractere
 * @param {number} speed - Velocidade de digita√ß√£o em ms
 */
function typeWriter(text, index = 0, speed = CONFIG.TYPING_SPEED) {
    const messageElement = document.querySelector(DOM_SELECTORS.message);
    if (!messageElement || index > text.length) {
        if (appState.typingInterval) {
            clearTimeout(appState.typingInterval);
            appState.typingInterval = null;
        }
        return;
    }
    
    messageElement.textContent = text.substring(0, index);
    appState.typingInterval = setTimeout(() => typeWriter(text, index + 1, speed), speed);
}

/**
 * Adiciona o aviso de copyright em elementos necess√°rios
 * @function addCopyrightNotice
 */
function addCopyrightNotice() {
    const copyrightText = '¬© 2025.2 ·π™HE√úSOFT ‚Äì ·π™ECNOLOGIA Q√úE APR√ñXIMA, ED√úCA√á√ÉO Q√úE TRANSF√ñRMA';
    
    // Adiciona ao elemento de copyright se existir
    const copyrightElement = document.querySelector(DOM_SELECTORS.copyright);
    if (copyrightElement) {
        copyrightElement.textContent = copyrightText;
    }
    
    // Log no console com branding
    console.log(`%c${copyrightText}`, 'color: #4A90E2; font-weight: bold; font-size: 12px;');
    console.log('%cEste software √© protegido por direitos autorais. N√£o copie ou distribua sem autoriza√ß√£o.', 'color: #666; font-style: italic;');
}

/**
 * Previne comportamentos indesejados como arrastar e selecionar
 * @function preventUndesiredActions
 */
function preventUndesiredActions() {
    // Prevenir comportamento padr√£o de arrastar
    document.addEventListener('dragstart', (e) => {
        e.preventDefault();
    });
    
    // Prevenir sele√ß√£o de texto
    document.addEventListener('selectstart', (e) => {
        e.preventDefault();
    });
}

/**
 * Inicializa as funcionalidades da p√°gina ap√≥s o preloader
 * @function initPageFunctionality
 */
function initPageFunctionality() {
    console.log('üöÄ Inicializando funcionalidades da p√°gina');
    
    // Adiciona avisos de copyright
    addCopyrightNotice();
    
    // Configura a atualiza√ß√£o de sauda√ß√£o
    updateGreeting();
    appState.greetingInterval = setInterval(updateGreeting, CONFIG.GREETING_UPDATE_INTERVAL);
    
    // Inicia efeito de digita√ß√£o
    const message = "Estamos passando por uma manuten√ß√£o r√°pida! Nossos servidores estar√£o de volta em breve. Agradecemos sua paci√™ncia e compreens√£o.";
    setTimeout(() => typeWriter(message), 500);
    
    // Previne a√ß√µes indesejadas
    preventUndesiredActions();
}

/**
 * Limpa intervalos e timeouts para evitar vazamentos de mem√≥ria
 * @function cleanupIntervals
 */
function cleanupIntervals() {
    if (appState.typingInterval) {
        clearTimeout(appState.typingInterval);
        appState.typingInterval = null;
    }
    if (appState.greetingInterval) {
        clearInterval(appState.greetingInterval);
        appState.greetingInterval = null;
    }
}

// EVENT LISTENERS

// Marca que a p√°gina foi carregada
window.addEventListener('load', () => {
    console.log('üìÑ P√°gina completamente carregada');
    appState.pageLoaded = true;
    handlePreloaderState();
});

// Configura timeout para o tempo m√≠nimo de exibi√ß√£o do preloader
setTimeout(() => {
    console.log('‚è∞ Tempo m√≠nimo do preloader atingido');
    appState.minTimeElapsed = true;
    handlePreloaderState();
}, CONFIG.PRELOADER_MIN_DISPLAY_TIME);

// Inicia as funcionalidades ap√≥s um pequeno delay
setTimeout(initPageFunctionality, 500);

// Limpa os intervalos quando a p√°gina √© descarregada
window.addEventListener('beforeunload', cleanupIntervals);
window.addEventListener('unload', cleanupIntervals);

// Tratamento de erros n√£o capturados
window.addEventListener('error', (e) => {
    console.error('‚ùå Erro n√£o capturado:', e.error);
});

// Tratamento de promessas rejeitadas n√£o tratadas
window.addEventListener('unhandledrejection', (e) => {
    console.warn('‚ö†Ô∏è Promessa rejeitada n√£o tratada:', e.reason);
    e.preventDefault();
});

// Inicializa√ß√£o do m√≥dulo
console.log('üîß PreloaderManager inicializado - ¬© 2025.2 ·π™HE√úSOFT');
